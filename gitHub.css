
https://htmlacademy.ru/blog/git/first-aid-git
шпаргалка гит
=
https://htmlacademy.ru/blog/git/useful-commands-for-working-with-git
полезные команды
==
$ git config --global user.name "Eugeniy Korotin"
$ git config --global user.email "your_email@example.com"

$ ssh-keygen -t ed25519 -C "kea-asd@yandex.ru"
$ ssh-keygen -t rsa -b 4096 -C "kea-asd@yandex.ru"

# start the ssh-agent in the background
$ eval "$(ssh-agent -s)"
> Agent pid 59566

авторизация через веб
$ gh auth login -w
$ ssh-add ~/.ssh/id_ed25519
$ ssh-add ~/.ssh/id_ed25519

ssh -T git@github.com


Семь правил классного комментария к коммиту

Помните: Все это уже было сказано раньше.
Отделяйте заголовок от тела пустой строкой
Ограничивайте заголовок 50 символами
Пишите заголовок с заглавной буквы
Не ставьте точку в конце заголовка
Используйте повелительное наклонение в заголовке
Переходите на следующую строку в теле на 72 символах
В теле отвечайте на вопросы что и почему, а не как
==

При работе с Git может возникнуть такая ситуация: команда git push не заливает изменения на сервер, а команда git status показывает:



$ git status

HEAD detached from 87dc87b



Это может означать, что вы делали какую-то навигацию по истории коммитов, и неправильно вернулись к последнему коммиту.

Исправить эту проблему можно 4-мя командами:

git branch temp
git checkout temp
git branch -f master temp
git checkout master



И, опционально,



git branch -d temp



Что при этом происходит:



1. создаем временную ветку с именем temp, причем в новой ветке будет правильно установлено положение HEAD
2. переключаемся на временную ветку temp
3. в ветке master устанавливается та же позиция HEAD, что и в ветке temp
4. переключиться на ветку master



И опционально:


5. удалить временную ветку





Еще один вариант, короткий



git checkout имяВеткиГдеВыНаходитесь



- эта команда переключит проект в последний коммит текущей ветки. Точнее, в состоянии detached head, проект не находится ни в какой ветке. git checkout branchname просто переключит проект на последний коммит той ветки, которая указана. Это значит, что до появления ошибки нужно знать, в какой ветке ты находишься. Для того чтобы посмотреть, где находился, можно воспользовтьася командой:



git reflog





Самый правильный вариант



git checkout HEAD@{1}

https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax
синтаксис 
=
http://coddism.com/zametki/razmetka_readmemd_v_github
имя
=
https://github.com/cyberspacedk/Git-commands
Шпаргалка 

https://www.youtube.com/watch?v=1upalKiDeEI
видео взаимодействие, гитпул форк совместная разработка
==
имя
$ git config --global user.name "Your name here"
$ git config --global user.email "your_email@example.com"
  команды на каждый день
git checkout -b new-branch 5589877   # создать ветку new-branch, начинающуюся с коммита c хешем 5589877 (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем)
git push origin feature #Загружает изменения в текущей ветви в origin в ветвь feature
  2.10. Синхронизация репозиториев 
    1. В локальном репозитории вводим команду git checkout master, переходим в ветку master.
    2.Заходим в мастер-репозиторий, копируем его SSH-адрес и вводим в терминале команду:
git remote add alias git@github.com:your-repo.git
  git remote add Studyrep git@github.com:Badsergeant/Studyrep.git
Отправляем изменения из своей ветки master в форк на GitHub с помощью команды git push origin master.
  
В этой команде вам нужно подставить свои данные:
    alias — короткое имя (алиас) для репозитория. На курсах для обращения к мастер-репозиторию мы используем алиас academy, 
  но вы можете выбрать любой другой: вместо academy указывайте своё название и оно закрепится за этим репозиторием.
    git@github.com:your-repo.git — путь к репозиторию (тот самый SSH-адрес, который вы копируете на странице репозитория).
  3. Теперь забираем (подтягиваем) изменения из ветки master мастер-репозитория командой git pull Studyrep master.
  После этого в ветке master локального форка появятся те же коммиты, что и в мастер-репозитории. Осталось отправить их в удалённый форк.
  Отправляем изменения из своей ветки master в форк на GitHub с помощью команды git push origin master.
  
  ==
  Когда ваш pull request примут, не забудьте слить изменения в свой репозиторий (или удалить его, если больше не нужен):
git checkout master # переходим в мастер
git pull upstream master # забираем
git push origin master
  Так же можно удалить ветку, в которой велась разработка:
git branch -d feature           # В локальном репозитории
git push origin :feature        # В удалённом репозитории

 
  команды 
git log --oneline лог коммитов
  git cat-file -p hash - покажет содержание коммита ( -р в человеческом виде)
  git cat-file -p (14d0040 это хеш)

  
сохранить изменения git push
Когда вы вернетесь домой, просто сделайте git pull , 
чтобы перенести изменения с работы на домашнюю машину.
Точно так же, когда вы закончите дома, сделайте git push ,
а затем, когда вернетесь на работу, сделайте git pull .

git remote add origin git@github.com:keaasd/fd.git
git branch -M main
git push -u origin main

  просмотр изменений
git status              # показать состояние репозитория (отслеживаемые, изменённые, новые файлы и пр.)
git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff index.html     # сравнить файл из рабочей директории и индекс
git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --staged       # сравнить индекс и коммит с HEAD
git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master
git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов
git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master  
  
  Добавление изменений в индекс
git add .        # добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий
git add text.txt # добавить в индекс указанный файл (был изменён, был удалён или это новый файл)
git add -i       # запустить интерактивную оболочку для добавления в индекс только выбранных файлов
git add -p       # показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании
  удаление из индекса
git reset            # убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод git add
git reset readme.txt # убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся)  
  
  Отмена изменений
git checkout text.txt      # ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе
git reset --hard           # ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)
git clean -df              # удалить неотслеживаемые файлы и директории

коммиты
git commit -m "Name of commit"    # зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение
git commit -a -m "Name of commit" # проиндексировать отслеживаемые файлы (ТОЛЬКО отслеживаемые, но НЕ новые файлы) и закоммитить, добавить сообщение

ветки
git branch                 # показать список веток
git branch -v              # показать список веток и последний коммит в каждой
git branch new_branch      # создать новую ветку с указанным именем на текущем коммите
git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите
git branch -f master 5589877  # переместить ветку master на указанный коммит
git branch -f master master~2 # переместить ветку master на 2 коммита назад
git checkout new_branch    # перейти в указанную ветку
git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё
git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё
git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix
git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния
git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
git branch --merged        # показать ветки, уже слитые с активной
git branch --no-merged     # показать ветки, не слитые с активной
git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name
git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name
git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории
git branch --unset-upstream # завершить процесс переименования

удаленный репозиторий
git remote -v              # показать список удалённых репозиториев, связанных с локальным
git branch -r              # показать удаленные ветки
git branch -a              # показать все ветки(локальные и удаленные)       
git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin
git remote add origin https://github.com:nicothin/test.git # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL
git remote rm origin       # удалить привязку удалённого репозитория
git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin
git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками
git fetch origin master    # то же, но скачивается только указанная ветка
git checkout --track origin/github_branch # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё
git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master
git pull origin            # влить изменения с удалённого репозитория (все ветки)
git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)

git merge feature                # влить в активную ветку изменения из ветки feature
git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток
git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки master)
git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)
git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)
git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки
Конфликт слияния
Предполагается ситуация: есть ветка master и есть ветка feature. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку master пытаемся влить ветку feature (git merge feature), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле index.html.

При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.

Работа с ветками, слияние и откат к состоянию до слияния
Была ветка fix, в которой исправляли баг. Исправили, влили fix в master. но тут выяснилось, что это исправление ломает какую-то функциональность, Нужно откатить master к состоянию без слияния (наличие бага менее критично, чем порча функциональности).
# находимся в ветке fix, баг уже «исправлен»
git checkout master            # переключаемся на master
git merge fix                  # вливаем изменения из fix в master
# видим проблему: часть функциональности сломалась
git checkout fix               # переключаемся на fix (пока мы в master, git не даст ее двигать)
git branch -f master ORIG_HEAD # передвигаем ветку master на коммит, указанный в ORIG_HEAD (тот, на который указывала master до вливания fix)


GitHub, BitBucket или GitLab?  (Последние две компании предлагают неограниченные бесплатные частные репозитории). 
  # The largest heading
## The second largest heading
###### The smallest heading
